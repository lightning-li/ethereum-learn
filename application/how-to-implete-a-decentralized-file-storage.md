### 如何实现一个去中心化的 Dropbox 存储

原标题：Secret Sharing and Erasure Coding: A Guide for the Aspiring Dropbox Decentralizer

作者：Vitalik Buterin   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;译者：李康

本文翻译自 https://blog.ethereum.org/2014/08/16/secret-sharing-erasure-coding-guide-aspiring-dropbox-decentralizer/

在去中心化计算的应用中，有一个激动人心的应用，在过去的一年里引起了相当大的兴趣，那就是受激励的去中心化在线文件存储系统的概念。目前，如果你想你的文件或者数据安全地在云端备份，你有3种选择：(1). 上传它们到自己的服务器，(2). 使用一个中心化的应用，如 Google drive 或者 Dropbox，或者是 (3). 使用已经存在的去中心化的应用，如 Freenet。这些方法都有它们自己的缺点：第一种方法有着昂贵的建立和维护费用；第二种方法依赖于一个单可信任实体，并且常常涉及重大价格上涨；第三种方法速度慢，对每一位用户在空间容量方面有着很高的限制，因为它依赖于用户自愿奉献存储空间。受激励的文件存储协议有潜力成为第四种方法，通过无中心化地激励执行者 (存储用户数据的客户) 参与其中，提供高容量存储与高质量服务。

大量的平台，包括 [Storj](http://storj.io/)、[Maidsafe](http://maidsafe.net/)，某种程度上，[Permacoin](http://cs.umd.edu/~amiller/permacoin.pdf) 与 [Filecoin](http://filecoin.io/)，正在尝试处理这个问题，该问题在某种意义上看起来是简单的，所有的工具要么已经存在了，要么正在构建的过程中，我们所需要的就是实现而已。然而，该问题其中的一小部分尤其重要：我们如何合适地引进冗余性？冗余对于安全来说至关重要，尤其是在一个去中心化的网络中，业余爱好者与临时性用户占大部分，我们绝对不能依赖于单节点保持在线。我们可以简单地复制用户数据，让一些节点存储单独的拷贝，问题是：我们能做的更好吗？事实证明，我们当然可以。

#### Merkle Trees 与 Challenge-Response 协议

在我们进入最为重要的冗余性部分之前，我们首先讲解一些更容易的部分：我们如何创建一个至少激励一个实体保持文件的最为基本的系统？没有激励的系统中，问题将会变得更加容易，你上传文件，等待其它的用户来下载它，当你再次需要该文件的时候，通过文件的哈希来发出一个查询请求。如果我们想引进激励机制，问题某种程度上变得更加困难，但是在大事的计划中，依旧不是那么难。

在文件存储的上下文中，有两种实体你可以激励。第一种是你发出一个下载文件的请求时，实际向你发送文件的实体。这很容易可以做；最好的策略是一种类似于简单的 tit-for-tat 游戏，发送者发送 32 kb，你发送 0.0001 个币，然后发送者发送另一 32 kb，以此类推。注意在没有冗余以及大文件的情形下，这个策略是极易受到敲诈勒索攻击的。一个文件的 99.99% 对于你来说是毫无用处的，所以存储者有机会敲诈你，让你为文件的最后一部分付出高昂的费用。对该问题最聪明的解决办法是，让文件是自冗余的，使用一种特殊的编码来扩展该文件，如文件 11.11% 自冗余，那么该文件的任意 90% 都可以来恢复原文件的内容，并且对存储者隐藏该文件的自冗余百分比。然而，随后针对不同的目的，我们将讨论一个非常类似的算法。所以现在，接受该问题已被解决。

第二种我们可以激励的行为实体是长期存储该文件的实体。该问题有些困难，如何在不真正传输整个文件的情况下，证明你存储着该文件？幸运地是，有一个不是很难实现的解决方案，使用在加密经济中，被用来构建信誉的结构：Merkle trees。

![haha](/images/2016/10/haha.jpg)

准确来说，某些情况下，Patricia Merkle 是更好的，尽管古老原始的 Merkle 树也能胜任。

基本的方法就是这个。首先，将文件分散为小块。或许每一块在 32 bytes 与 1024 bytes 之间，添加全 0 的块，直到块数量达到 `n = 2 ^ k` (添补的步骤是可以避免的，但是它使得算法编码和解释更加简单)。接下来，我们构建树。重命名 `n` 个块为 `chunk[n]` 到 `chunk[2n-1]`，并且使用以下规则重新构建块  `1` 到 `n-1`：`chunk[i] = sha3([chunk[2*i], chunk[2*i+1]])`。这使得你计算出块 `n/2` 到 `n-1`，然后 `n/4` 到 `n/2 - 1`，然后重复上述步骤直至得到一个 *root*， `chunk[1]`。

![Merkle](/images/2016/10/merkle.png)

现在，注意如果你仅仅存储根节点，忘记 `chunk[2]...chunk[2n-1]`，存储其它块的实体通过几百字节就能向你证明，他们拥有某个特定块。这个算法相对来说比较简单。首先，我们定义一个函数 `partner(n)`，如果 `n` 是奇数，输出 `n-1`，如果 `n` 是偶数，输出 `n+1` - 简单来说，就是给定一个块，找出和该块链接在一起产生父区块的块。然后，如果你想证明 `chunk[k]` (`n <= k <= 2n - 1`) 的所有权，提交 `chunk[partner(k)]`，`chunk[partner(k/2)]` (除法在这里意味着向下取整，例如 `11 / 2 = 5`)，`chunk[partner(k/4)]` 等等直到 `chunk[1]`，与真正的 `chunk[k]` 一起。本质上，我们提供的是从块 `k` 到根节点的整个分支。验证者使用 `chunk[k]` 与 `chunk[partner(k)]` 构建 `chunk[k/2]`，使用刚生成的 `chunk[k/2]` 与 `chunk[partner(k/2)]` 构建 `chunk[k/4]`，直到验证者得到 `chunk[1]`，该树的根节点，如果根节点与验证者自存的根节点匹配，那么该证据就是有效的，否则无效。

![Merkle_verify](/images/2016/10/merkle_verify.png)

上图是块 10 的证据，包括 (1). chunk 10，(2). chunk 11 (`11=partner(10)`)，4 (`4 = partner(10/2)`)，3 (`3 = partner(10/4)`)。验证过程从块 10 开始，使用它们的 partner 来产生父区块，直到产生根节点 chunk 1，看是否匹配验证者节点自存储的根节点。

注意证据隐式地包含了索引--在哈希之前有时你需要将 partner 加到左边，有的时候是右边，如果用来验证证据的索引是不同的，那么该证据将不再匹配。因此，如果我要求一个 `chunk 422` 的证据，你提供了一个即使有效的 `chunk 587` 的证据，我也会注意到出了错误。同样地，如果没有 Merkle Tree 的整个相关的部分，那么你没有任何办法提供一个有效证据；如果你试图传输伪造的数据，在某一点，哈希将不会匹配，导致最终的根节点会是不同的。

现在，让我们回顾一下这个协议。按照上述描述，我在文件之外构建了一棵 Merkle 树，然后上传给某个实体。然后，每 12 个小时，我找一个位于 `[0, 2^k-1]` 中的随机数，提交该随机数要求存储者提供证据。如果存储者回复了相应 Merkle tree 证据，然后我验证该证据，如果该证据是正确的，则发送 0.001 BTC (或者 ETH，或 storjcoin，或者任意使用的代币)。如果我没有接收到相应证据或者证据是无效的，那么我不会发送 BTC。如果存储者存储了整个文件，他们将会在所有的验证时间点成功，如果他们存储了文件的 50%，他们将会有 50% 的验证时间点是成功的，等等。如果我们想让它要么全部成功要么失败，那么我们可以简单地要求存储者提供 10 个连续的证据，这样存储者才可以得到奖励。存储者仍然可以就传输文件的 99% 进行敲诈勒索，但是我们可以利用我上面提到的冗余编码策略，在任何情况下文件的 90% 就足以恢复出原文件，这种策略将在下面描述。

这时你可能会关心的一点是隐私 - 如果你使用一个加密协议来让任意节点存储你的文件以获得奖励，难道那不意味着你的文件散落在互联网的各个角落，任何节点可以潜在地访问这些文件？幸运的是，该问题的答案是简单的：在发送文件之前，加密整个文件。从这一点上，我们假设所有的数据都是加密的，忽略掉隐私问题，因为目前的加密方法几乎完全解决了该问题 (几乎是因为，文件的大小，你访问文件的时间，依旧是公开的)。

#### 深入到去中心化 (Looking to Dencentralize)

现在我们有一个使人们存储你的数据来获得奖励的协议；该算法甚至可以通过将其放入 Ethereum 合约中来实现无需信任 (trust-free)，使用 `block.prevhash` 作为生成挑战 (注：挑战指向存储者索要某一特定块的 Merkle Tree 证据) 的随机数源。现在，让我们进行下一步：指出如何去中心化存储和增加冗余。去中心化的最简单方式是简单的复制：取而代之一个节点存储一份文件的拷贝，我们可以让五个节点分别都存储一份文件的拷贝。然而，如果我们简单地遵循上述提到的天真协议，我们会有一个问题：一个节点可以假装成五个节点，得到五倍的回报。一个快速解决该问题的办法是五次加密原文件
，那么一个存储者将不能注意到五份文件其实是相同的，从而存储它们一次但是索要 5 倍奖励。

但是即使这样，我们依然有两个问题。第一个，没有任何办法验证文件的五份拷贝被五个分开的用户存储，如果你想让你的文件被去中心化的云来备份，你就会为去中心化的服务付款；如果所有的五个用户实际上是通过 Google 或者 Amazon 存储任何数据，这将会使得该协议没有多大实用性。这是一个非常困难的问题，尽管五次加密文件，假装你正在存储五个不同的文件，可以阻止参与者使用一份存储来获取五倍奖励，却不能阻止一个参与者使用五份存储来获取五倍奖励，并且从存储者的角度来看，经济规模甚至意味着这种情形是可取的。第二个，存在一种问题，你花费了巨大开销，尤其是，你从并没有获取到太多冗余性的存储者那里花费了不应该的冗余性支出 - 例如，如果一个单节点有 50% 的可能会离线 (非常合理的一个预估，如果我们正在讨论的是一个在个人硬盘剩余空间存储的文件网络)，那么你有 6.25% 的可能会完全不能访问该文件 (译者注：这里指的可能是四个存储者的情况)。

针对第一个问题，有一种解决方案，尽管它是有缺陷的并且不清楚带来的好处是否值得这样去做。思想就是使用**权益证明 (proof of stake)**协议与**[保管证明 (proof of custody)](https://docs.google.com/a/ethereum.org/document/d/1F81ulKEZFPIGNEVRsx0H1gl2YRtf0mUMsX011BzSjnY/edit) - 一种文件与私钥同时拥有的证明 **的结合。如果你想存储你的文件，想法是随机选择某个数量的某种货币的权益持有者，通过他们拥有的货币数量来赋予他们被选择的可能性权重。用 Ethereum 合约的方式来实现权益证明可能包括，让参与者存放 ether (以太币) 到合约中 (记住，这里存放 ether 是无需信任的，如果合约提供了一种赎回 ether 的方式)，然后给每一个账户与他们存款成比例的可能性，接下来这些权益持有者将会有机会存储文件。然后，取而代之上面提到的简单 Merkle 树检测，保管证明协议会被使用。

保管证明协议有 non-outsourceable 的好处，也就是，如果不给服务器访问你的私钥，没有任何方法可以将文件放入服务器中。这意味着，至少在理论上，用户将不会倾向于在中心化的云计算系统中存储大量的文件。当然，协议完成这个是以验证需要更高花费为代价的。所以，留下一个开放的问题：我们是想要保管证明以及其带来的验证开销，还是以防万一而引进额外的冗余
所带来的存储开销？
