### 如何实现一个去中心化的 Dropbox 存储

原标题：Secret Sharing and Erasure Coding: A Guide for the Aspiring Dropbox Decentralizer

作者：Vitalik Buterin   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;译者：李康

本文翻译自 https://blog.ethereum.org/2014/08/16/secret-sharing-erasure-coding-guide-aspiring-dropbox-decentralizer/

在去中心化计算的应用中，有一个激动人心的应用，在过去的一年里引起了相当大的兴趣，那就是受激励的去中心化在线文件存储系统的概念。目前，如果你想你的文件或者数据安全地在云端备份，你有3种选择：(1). 上传它们到自己的服务器，(2). 使用一个中心化的应用，如 Google drive 或者 Dropbox，或者是 (3). 使用已经存在的去中心化的应用，如 Freenet。这些方法都有它们自己的缺点：第一种方法有着昂贵的建立和维护费用；第二种方法依赖于一个单可信任实体，并且常常涉及重大价格上涨；第三种方法速度慢，对每一位用户在空间容量方面有着很高的限制，因为它依赖于用户自愿奉献存储空间。受激励的文件存储协议有潜力成为第四种方法，通过无中心化地激励执行者 (存储用户数据的客户) 参与其中，提供高容量存储与高质量服务。

大量的平台，包括 [Storj](http://storj.io/)、[Maidsafe](http://maidsafe.net/)，某种程度上，[Permacoin](http://cs.umd.edu/~amiller/permacoin.pdf) 与 [Filecoin](http://filecoin.io/)，正在尝试处理这个问题，该问题在某种意义上看起来是简单的，所有的工具要么已经存在了，要么正在构建的过程中，我们所需要的就是实现而已。然而，该问题其中的一小部分尤其重要：我们如何合适地引进冗余性？冗余对于安全来说至关重要，尤其是在一个去中心化的网络中，业余爱好者与临时性用户占大部分，我们绝对不能依赖于单节点保持在线。我们可以简单地复制用户数据，让一些节点存储单独的拷贝，问题是：我们能做的更好吗？事实证明，我们当然可以。

#### Merkle Trees 与 Challenge-Response 协议

在我们进入最为重要的冗余性部分之前，我们首先讲解一些更容易的部分：我们如何创建一个至少激励一个实体保持文件的最为基本的系统？没有激励的系统中，问题将会变得更加容易，你上传文件，等待其它的用户来下载它，当你再次需要该文件的时候，通过文件的哈希来发出一个查询请求。如果我们想引进激励机制，问题某种程度上变得更加困难，但是在大事的计划中，依旧不是那么难。

在文件存储的上下文中，有两种实体你可以激励。第一种是你发出一个下载文件的请求时，实际向你发送文件的实体。这很容易可以做；最好的策略是一种类似于简单的 tit-for-tat 游戏，发送者发送 32 kb，你发送 0.0001 个币，然后发送者发送另一 32 kb，以此类推。注意在没有冗余以及大文件的情形下，这个策略是极易受到敲诈勒索攻击的。一个文件的 99.99% 对于你来说是毫无用处的，所以存储者有机会敲诈你，让你为文件的最后一部分付出高昂的费用。对该问题最聪明的解决办法是，让文件是自冗余的，使用一种特殊的编码来扩展该文件，如文件 11.11% 自冗余，那么该文件的任意 90% 都可以来恢复原文件的内容，并且对存储者隐藏该文件的自冗余百分比。然而，随后针对不同的目的，我们将讨论一个非常类似的算法。所以现在，接受该问题已被解决。

第二种我们可以激励的行为实体是长期存储该文件的实体。该问题有些困难，如何在不真正传输整个文件的情况下，证明你存储着该文件？幸运地是，有一个不是很难实现的解决方案，使用在加密经济中，被用来构建信誉的结构：Merkle trees。

![haha](/images/2016/10/haha.jpg)

准确来说，某些情况下，Patricia Merkle 是更好的，尽管古老原始的 Merkle 树也能胜任。

基本的方法就是这个。首先，将文件分散为小块。或许每一块在 32 bytes 与 1024 bytes 之间，添加全 0 的块，直到块数量达到 `n = 2 ^ k` (添补的步骤是可以避免的，但是它使得算法编码和解释更加简单)。接下来，我们构建树。重命名 `n` 个块为 `chunk[n]` 到 `chunk[2n-1]`，并且使用以下规则重新构建块  `1` 到 `n-1`：`chunk[i] = sha3([chunk[2*i], chunk[2*i+1]])`。这使得你计算出块 `n/2` 到 `n-1`，然后 `n/4` 到 `n/2 - 1`，然后重复上述步骤直至得到一个 *root*， `chunk[1]`。

![Merkle](/images/2016/10/merkle.png)

现在，注意如果你仅仅存储根节点，忘记 `chunk[2]...chunk[2n-1]`，存储其它块的实体通过几百字节就能向你证明，他们拥有某个特定块。这个算法相对来说比较简单。首先，我们定义一个函数 `partner(n)`，如果 `n` 是奇数，输出 `n-1`，如果 `n` 是偶数，输出 `n+1` - 简单来说，就是给定一个块，找出和该块链接在一起产生父区块的块。然后，如果你想证明 `chunk[k]` (`n <= k <= 2n - 1`) 的所有权，提交 `chunk[partner(k)]`，`chunk[partner(k/2)]` (除法在这里意味着向下取整，例如 `11 / 2 = 5`)，`chunk[partner(k/4)]` 等等直到 `chunk[1]`，与真正的 `chunk[k]` 一起。本质上，我们提供的是从块 `k` 到根节点的整个分支。验证者使用 `chunk[k]` 与 `chunk[partner(k)]` 构建 `chunk[k/2]`，使用刚生成的 `chunk[k/2]` 与 `chunk[partner(k/2)]` 构建 `chunk[k/4]`，直到验证者得到 `chunk[1]`，该树的根节点，如果根节点与验证者自存的根节点匹配，那么该证据就是有效的，否则无效。

![Merkle_verify](/images/2016/10/merkle_verify.png)

上图是块 10 的证据，包括 (1). chunk 10，(2). chunk 11 (`11=partner(10)`)，4 (`4 = partner(10/2)`)，3 (`3 = partner(10/4)`)。验证过程从块 10 开始，使用它们的 partner 来产生父区块，直到产生根节点 chunk 1，看是否匹配验证者节点自存储的根节点。

注意证据隐式地包含了索引--在哈希之前有时你需要将 partner 加到左边，有的时候是右边，如果用来验证证据的索引是不同的，那么该证据将不再匹配。因此，如果我要求一个 `chunk 422` 的证据，你提供了一个即使有效的 `chunk 587` 的证据，我也会注意到出了错误。同样地，如果没有 Merkle Tree 的整个相关的部分，那么你没有任何办法提供一个有效证据；如果你试图传输伪造的数据，在某一点，哈希将不会匹配，导致最终的根节点会是不同的。

现在，让我们回顾一下这个协议。按照上述描述，我在文件之外构建了一棵 Merkle 树，然后上传给某个实体。然后，每 12 个小时，我找一个位于 `[0, 2^k-1]` 中的随机数，提交该随机数要求存储者提供证据。如果存储者回复了相应 Merkle tree 证据，然后我验证该证据，如果该证据是正确的，则发送 0.001 BTC (或者 ETH，或 storjcoin，或者任意使用的代币)。如果我没有接收到相应证据或者证据是无效的，那么我不会发送 BTC。如果存储者存储了整个文件，他们将会在所有的验证时间点成功，如果他们存储了文件的 50%，他们将会有 50% 的验证时间点是成功的，等等。如果我们想让它要么全部成功要么失败，那么我们可以简单地要求存储者提供 10 个连续的证据，这样存储者才可以得到奖励。存储者仍然可以就传输文件的 99% 进行敲诈勒索，但是我们可以利用我上面提到的冗余编码策略，在任何情况下文件的 90% 就足以恢复出原文件，这种策略将在下面描述。

这时你可能会关心的一点是隐私 - 如果你使用一个加密协议来让任意节点存储你的文件以获得奖励，难道那不意味着你的文件散落在互联网的各个角落，任何节点可以潜在地访问这些文件？幸运的是，该问题的答案是简单的：在发送文件之前，加密整个文件。从这一点上，我们假设所有的数据都是加密的，忽略掉隐私问题，因为目前的加密方法几乎完全解决了该问题 (几乎是因为，文件的大小，你访问文件的时间，依旧是公开的)。

#### 深入到去中心化 (Looking to Dencentralize)

现在我们有一个使人们存储你的数据来获得奖励的协议；该算法甚至可以通过将其放入 Ethereum 合约中来实现无需信任 (trust-free)，使用 `block.prevhash` 作为生成挑战 (注：挑战指向存储者索要某一特定块的 Merkle Tree 证据) 的随机数源。现在，让我们进行下一步：指出如何去中心化存储和增加冗余。去中心化的最简单方式是简单的复制：取而代之一个节点存储一份文件的拷贝，我们可以让五个节点分别都存储一份文件的拷贝。然而，如果我们简单地遵循上述提到的天真协议，我们会有一个问题：一个节点可以假装成五个节点，得到五倍的回报。一个快速解决该问题的办法是五次加密原文件
，那么一个存储者将不能注意到五份文件其实是相同的，从而存储它们一次但是索要 5 倍奖励。

但是即使这样，我们依然有两个问题。第一个，没有任何办法验证文件的五份拷贝被五个分开的用户存储，如果你想让你的文件被去中心化的云来备份，你就会为去中心化的服务付款；如果所有的五个用户实际上是通过 Google 或者 Amazon 存储任何数据，这将会使得该协议没有多大实用性。这是一个非常困难的问题，尽管五次加密文件，假装你正在存储五个不同的文件，可以阻止参与者使用一份存储来获取五倍奖励，却不能阻止一个参与者使用五份存储来获取五倍奖励，并且从存储者的角度来看，经济规模甚至意味着这种情形是可取的。第二个，存在一种问题，你花费了巨大开销，尤其是，你从并没有获取到太多冗余性的存储者那里花费了不应该的冗余性支出 - 例如，如果一个单节点有 50% 的可能会离线 (非常合理的一个预估，如果我们正在讨论的是一个在个人硬盘剩余空间存储的文件网络)，那么你有 6.25% 的可能会完全不能访问该文件 (译者注：这里指的可能是四个存储者的情况)。

针对第一个问题，有一种解决方案，尽管它是有缺陷的并且不清楚带来的好处是否值得这样去做。思想就是使用**权益证明 (proof of stake)**协议与**[保管证明 (proof of custody)](https://docs.google.com/a/ethereum.org/document/d/1F81ulKEZFPIGNEVRsx0H1gl2YRtf0mUMsX011BzSjnY/edit) - 一种文件与私钥同时拥有的证明 **的结合。如果你想存储你的文件，想法是随机选择某个数量的某种货币的权益持有者，通过他们拥有的货币数量来赋予他们被选择的可能性权重。用 Ethereum 合约的方式来实现权益证明可能包括，让参与者存放 ether (以太币) 到合约中 (记住，这里存放 ether 是无需信任的，如果合约提供了一种赎回 ether 的方式)，然后给每一个账户与他们存款成比例的可能性，接下来这些权益持有者将会有机会存储文件。然后，取而代之上面提到的简单 Merkle 树检测，保管证明协议会被使用。

保管证明协议有 non-outsourceable 的好处，也就是，如果不给服务器访问你的私钥，没有任何方法可以将文件放入服务器中。这意味着，至少在理论上，用户将不会倾向于在中心化的云计算系统中存储大量的文件。当然，协议完成这个是以验证需要更高花费为代价的。所以，留下一个开放的问题：我们是想要保管证明以及其带来的验证开销，还是以防万一而引进额外的冗余
所带来的存储开销？

#### M of N

不管保管证明是否是一个好主意，下一步是看看我们在冗余性方面能否比原生且幼稚的复制范例 (简单地将文件复制分发到各个节点) 做的更好。首先，我们分析一下原生的复制范例有多么好。假定每个节点有 50% 的可用时间，并且你愿意花费 4 倍开销。在这些情况下，失败的可能性有 `0.5 ^ 4 = 0.0625` - 跟中心化服务提供的 4 个 9 (例如，99.99% 可用时间) 相比还是挺高的，一些中心化服务甚至提供 5 个 或 6 个 9 以上的可用时间，但是由于[黑天鹅理论 (Talebian black swan considerations)](https://en.wikipedia.org/wiki/Black_swan_theory)，任何超过 3 个 9 的承诺都可以被认为是废话；因为去中心化的网络不依赖于任何具体公司的存在或者行为或者是具体的软件包，去中心化系统实际可论证地可以合理提供 4 个 9 以上的承诺。如果我们假设参与去中心化网络的用户是类似专业的挖矿者，那么我们可以降低节点不可用时间的比例，如到 10%。在这种情况下，我们实际可以得到 `1 - 0.1 ^ 4 = 0.9999` 可用时间，但是理应假设更悲观的情况。

现在我们需要的是某种 M-of-N 协议，就像[比特币中的多方签名 (multisig for Bitcoin) ](http://bitcoinmagazine.com/11108/multisig-future-bitcoin/)。那么首先我们描述一下我们理想中的协议应该是怎样的，然后随后再考虑它是否是可行的。假定我们有一个大小为 1G 的文件，我们想"多方签名"它到 20-of-60 中。我们将文件分割为 60 块，每块大小为 50 MB (总共 3 GB)，如此这 60 块中的任意 20 块足够重建原始文件。这是信息理论中最优情况；你不能从少于 1 G 字节的信息中恢复出 1 G 字节的信息，但是从 1 G 字节的信息中恢复出 1 G 字节的信息是完全可能的。如果我们有一种类似的协议，我们可以使用该协议将文件分割为 60 块，单独得加密这 60 块，使得它们看起来像独立的文件，然后单独地对这 60 块分别应用受激励的文件存储协议。

现在，有趣的部分来了：这样的一个协议确实存在。在文章的下一部分，我们将要描一点数学知识，被称作为**"secret sharing"** 或者**"erasure coding"**。这些名字使用的算法基本是相同的，除了一些实现细节。为了开始，我们回顾一个简单的定理：两点决定一条直线。

![twopoints](/images/2016/10/twopoints.png)

尤其是，注意到，恰好有一条直线穿过其中任意两点，但是有无穷条直线穿过其中一点。由这个简单的定理，我们可以制定一个受限制的 2-of-n 版本：把文件的一半看作是坐标系中的一点 `(x=1, y=文件一半的内容)`，把文件的另一半看作是坐标系中另一点 `(x=2, y=文件另一半的内容)`，画出穿过两点的直线，并且取 x 轴为 3 与 4 的点，等等。这样，任意两块能被用来重建这条直线，从这条直线中获取 `x=1, x=2` 对应的 y 轴，从而恢复原文件。

数学上，有两种方法完成这个。第一种是相对简单的方法，包括一个线性方程的系统即可。假定我们想分割的文件内容是数字 "1321"。左半部分是 13，右半部分是 21，所以直线穿过 `(1, 13), (2, 21)` 两点。如果我们想知道斜率以及这条直线上 y 轴特点，我们可以解决该线性方程系统：

```
1 * a + b = 13
2 * a + b = 21
```

让第二个方程减去第一个方程，得到：

```
a = 8
```

将其带入第一个方程，得到：

```
b = 5
```

所以我们得到了等式，`y = 8 * x + 5`。我们可以生成新点：`(3, 29)`，`(4, 27)`，等等。从这些点中任意两点，我们都可以恢复原始的等式。

现在，让我们更进一步，生成 m-of-n 版本。事实证明，这是更复杂的，但是也不是那么难，我们知道两点决定一条直线。我们同时也知道三点决定一条抛物线。

![threepoints](/images/2016/10/threepoints.png)

因此，对于 3-of-n，我们就可以将文件分割为 3 块，由 `x = 1, 2, 3` 三点组成抛物线，然后在该抛物线上取第四个点或更多的点作为附加块。如果我们想要 4-of-n，就要使用三次抛物线。我们具体看一下后一种情况，我们仍然假设原始文件为 “1321”，但是我们使用 4-of-7 来将该文件分割。我们的四个点为 `(1, 1)`，`(2, 3)`，`(3, 2)`，`(4, 1)`。所以我们有：

```
a * 1 ^ 3 + b * 1 ^ 2 + c * 1 + d = 1
a * 2 ^ 3 + b * 2 ^ 2 + c * 2 + d = 3
a * 3 ^ 3 + b * 3 ^ 2 + c * 3 + d = 2
a * 4 ^ 3 + b * 4 ^ 2 + c * 4 + d = 1
```

哦！让我们开始进行减法，我们将使用等式 2 减去等式 1，等式 3 减去等式 2，等式 4 减去等式 3，这样就可以将 4 个等式转换为 3 个等式，然后一次一次重复上述步骤。

```
a * 7 + b * 3 + c = 2
a * 19 + b * 5 + c = -1
a * 37 + b * 7 + c = -1
```

```
a * 12 + b * 2 = -3
a * 18 + b * 2 = 0
```

```
a * 6 = 3
```

所以 `a = 1/2`，现在我们逐步解开此方程，得到：

```
1/2 * 12 + b * 2 = -3
```

所以 `b = -9/2`，然后：

```
1/2 * 7 - 9/2 * 3 + c = 2
```

所以 `c = 12`，然后：

```
1/2 - 9/2 + 12 + d = 1
```

所以 `a = 0.5`，`b = -4.5`，`c = 12`，`d = -7`。这是形象化的可爱抛物线：

![fourpoints](/images/2016/10/fourpoints.png)

我创建了一个 Python 版实用工具来帮助你完成这些操作 (这个工具能做一些更高级的操作，但是我们随后深入它)；你可以在[这里](https://github.com/ethereum/economic-modeling/tree/master/erasure_code)下载它，如果你想快速解决上面提到的等式方程组，你可以：

```
> import share
> share.sys_solve([[1.0, 1.0, 1.0, 1.0, -1.0], [8.0, 4.0, 2.0, 1.0, -3.0], [27.0, 9.0, 3.0, 1.0, -2.0], [64.0, 16.0, 4.0, 1.0, -1.0]])
[0.5, -4.5, 12.0, -7.0]
```

注意把值设置为浮点数是必须的。如果你使用整数，Python 的整数除法会将所有的事情搞乱。

现在，我们介绍一种更容易的方式来完成它，**拉格朗日插值法 (Lagrange interpolation)**。这里思想是非常聪明的：我们提出一个三次抛物线，它在 `x = 1` 处的值为 `1`，在 `x = 2, 3, 4` 处的值为 `0`，然后针对每一个其它的 x 坐标做相同的操作 (`x = 2` 处为 `1`，`x = 1, 3, 4` 处为 `0`)。然后，我们做乘法，并将抛物线方程加在一起；例如，为了匹配 `(1, 3, 2, 1)`，我们简单地用 1 乘以抛物线 (它的 y 轴为 (1, 0, 0, 0))，用 3 乘以抛物线 (它的 y 轴为 (0, 1, 0, 0))，用 2 乘以抛物线 (它的 y 轴为 (0, 0, 1, 0))，用 1 乘以抛物线 (它的 y 轴为 (0, 0, 0, 1))，然后将这些抛物线方程加在一起来得到目标抛物线 (它的 y 轴为 (1, 3, 2, 1))。这个小技巧是有效的，因为四个点唯一决定一个三次抛物线方程。这看起来不是那么简单，因为我们目前这种用点带入抛物线方程的方法太笨拙了，但是幸运的是，对于它，我们有一个显示的构建方法：

![CodeCogsEqn-19](/images/2016/10/CodeCogsEqn-19.gif)
